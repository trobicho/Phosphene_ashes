#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#define M_PI  3.14159265

#include "hostDevice.h"
#include "pathcommon.glsl"

layout(set = 0, binding = eTlas) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eImageOut, rgba32f) uniform image2D image;
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };

layout(location = 0) rayPayloadEXT hitPayload prd;

layout(push_constant) uniform _PushConstantRay
{
  PushConstantRay pcRay;
};

float   randN = 1;

float   rand()
{
  vec2    co = gl_LaunchIDEXT.xy + randN + uni.time;

  float a = 12.9898;
  float b = 78.233;
  float c = 43758.5453;
  float dt= dot(co.xy, vec2(a,b));
  float sn= mod(dt, 3.1415);
  randN += 0.587;
  return fract(sin(sn) * c);
}

vec2    box_muller()
{
  float   r1 = rand();
  float   r2 = rand();
  float   tmp = sqrt(-2 * log(r1));
  vec2    d = vec2(tmp * cos(2 * M_PI * r2), tmp * sin(2 * M_PI * r2));

  return (d);
}

void main() 
{
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5) + box_muller() / 2.5;
  const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;

  vec3  currentColor = vec3(0);
  if (pcRay.nbConsecutiveRay > 0)
    currentColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;

  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);
  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);
  
  uint  rayFlags = gl_RayFlagsOpaqueEXT;
  float tMin     = 0.00001;
  float tMax     = 10000.0;

  traceRayEXT(topLevelAS, // acceleration structure
    rayFlags,       // rayFlags
    0xFF,           // cullMask
    0,              // sbtRecordOffset
    0,              // sbtRecordStride
    0,              // missIndex
    origin.xyz,     // ray origin
    tMin,           // ray min range
    direction.xyz,  // ray direction
    tMax,           // ray max range
    0               // payload (location = 0)
  );

  uint  count = pcRay.nbConsecutiveRay;

  vec3  color = (currentColor * count) + prd.color;
  color /= count + 1;
  imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}
