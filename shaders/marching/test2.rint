#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "../raycommon.glsl"
#include "marchingBasicSD.glsl"
#include "marchingBasicShape.glsl"

hitAttributeEXT block {
  vec3  pos;
  vec3  normal;
  uint  step;
  vec3  color;
  float minDist;
}attribs;

#define ITER   10

int last = 0;

float sdf(in vec3 p)
{
  float   bailout = 10.0;
  float   scale = 2.0;
  float   offset = 3.0;

  float   r = dot(p, p);
  mat4    M;
  int     i;
  vec3    c = vec3(0.0, 1.0, 0.0);

  for(i = 0; i < ITER && r < bailout; i++)
  {
    last = i % 3;
    M = rotation_matrix(c - p, radians(3 * i));
    p = (vec4(p, 1.0) * M).xyz;
    if (p.x + p.y < 0) p.xy = -p.yx;
    if (p.x + p.z < 0) p.xz = -p.zx;
    if (p.y + p.z < 0) p.zy = -p.yz;
    p = p * scale - (scale - 1.0);
    r = dot(p, p);
  }
  return (torus_de(p, 2, 0.5) * pow(scale, -i));
}

#define MAX_DIST    10.0 
#include "marching.glsl"

vec3  getColor(in Hit hit)
{
  vec3 color = vec3(1.0);

  color /= hit.step / 10;

  if (last == 0)
    color.x *= 3.0;
  else if (last == 1)
    color.y *= 3.0;
  else
    color.z *= 3.0;

  return (color);
}

void  main()
{
  float   minDist = 0.001;
  uint    maxStep = 1000;
  Ray     ray = {gl_ObjectRayOriginEXT, gl_ObjectRayDirectionEXT};

  Sphere  sphere = {vec3(0.f, 0.f, 0.0f), 1.f};
  float   dist = hitSphere(sphere, ray);
  float   distT = 0;
  if (dist > 0) {
    ray.origin = ray.origin + ray.direction * dist;
    distT = dist;
  }

  Hit hit = marching(ray, minDist, maxStep);
  hit.dist += distT;
  if (hit.asHit) {
    Ray   rayNormal = {hit.pos, ray.direction};
    vec3  normal = getNormal(rayNormal, minDist);
    attribs.pos = hit.pos;
    attribs.normal = normal;
    attribs.step = hit.step;
    attribs.color = getColor(hit);
    float result = abs(hit.dist);
    result += minDist;
    attribs.minDist = minDist;
    reportIntersectionEXT(result, 1);
  }
  else {
    reportIntersectionEXT(0.1, 1);
  }
}
